diff --git a/Makefile b/Makefile
index b437a346..db1d5341 100644
--- a/Makefile
+++ b/Makefile
@@ -491,7 +491,7 @@ $(TARGET_DIRS_RULES):
 	$(call quiet-command,$(MAKE) $(SUBDIR_MAKEFLAGS) -C $(dir $@) V="$(V)" TARGET_DIR="$(dir $@)" $(notdir $@),)
 
 DTC_MAKE_ARGS=-I$(SRC_PATH)/dtc VPATH=$(SRC_PATH)/dtc -C dtc V="$(V)" LIBFDT_srcdir=$(SRC_PATH)/dtc/libfdt
-DTC_CFLAGS=$(CFLAGS) $(QEMU_CFLAGS)
+DTC_CFLAGS=$(CFLAGS) $(QEMU_CFLAGS) -rdynamic -ggdb3
 DTC_CPPFLAGS=-I$(BUILD_DIR)/dtc -I$(SRC_PATH)/dtc -I$(SRC_PATH)/dtc/libfdt
 
 .PHONY: dtc/all
diff --git a/accel/tcg/cpu-exec.c b/accel/tcg/cpu-exec.c
index c01f59c7..e1a24dd7 100644
--- a/accel/tcg/cpu-exec.c
+++ b/accel/tcg/cpu-exec.c
@@ -146,6 +146,27 @@ static inline tcg_target_ulong cpu_tb_exec(CPUState *cpu, TranslationBlock *itb)
     int tb_exit;
     uint8_t *tb_ptr = itb->tc.ptr;
 
+#if defined(TARGET_ARM)
+    if (qemu_loglevel_mask(CPU_LOG_EXEC)) {
+        qemu_log_lock();
+        /* rather than logging just PC, also log the disassembled code */
+        if (!singlestep) {
+            /* separate translation blocks by newlines */
+            qemu_log("\n");
+        }
+        /* some instructions are printed more than once, not sure why */
+        static int prev_pc = -1;
+        if (itb->pc != prev_pc) {
+            prev_pc = itb->pc;
+            if (CPU_NEXT(first_cpu)) {
+                qemu_log("[CPU%d] ", current_cpu->cpu_index);
+            }
+            log_target_disas(cpu, itb->pc, itb->size);
+        }
+        qemu_log_unlock();
+    }
+#endif
+
     qemu_log_mask_and_addr(CPU_LOG_EXEC, itb->pc,
                            "Trace %d: %p ["
                            TARGET_FMT_lx "/" TARGET_FMT_lx "/%#x] %s\n",
@@ -392,6 +413,16 @@ static inline void tb_add_jump(TranslationBlock *tb, int n,
     return;
 }
 
+static void (*tb_exec_cb)(void *opaque, CPUState *cpu, TranslationBlock *tb);
+static void * tb_exec_opaque;
+
+void cpu_set_tb_exec_cb(void (*cb)(void *opaque, CPUState *cpu, TranslationBlock *tb),
+                        void *opaque)
+{
+    tb_exec_cb = cb;
+    tb_exec_opaque = opaque;
+}
+
 static inline TranslationBlock *tb_find(CPUState *cpu,
                                         TranslationBlock *last_tb,
                                         int tb_exit, uint32_t cf_mask)
@@ -417,6 +448,9 @@ static inline TranslationBlock *tb_find(CPUState *cpu,
         last_tb = NULL;
     }
 #endif
+    if (tb_exec_cb) {
+        tb_exec_cb(tb_exec_opaque, cpu, tb);
+    }
     /* See if we can patch the calling TB. */
     if (last_tb) {
         tb_add_jump(last_tb, tb_exit, tb);
diff --git a/default-configs/arm-softmmu.mak b/default-configs/arm-softmmu.mak
index 1f2e0e7f..cc5f7eb8 100644
--- a/default-configs/arm-softmmu.mak
+++ b/default-configs/arm-softmmu.mak
@@ -28,6 +28,7 @@ CONFIG_SPITZ=y
 CONFIG_TOSA=y
 CONFIG_Z2=y
 CONFIG_COLLIE=y
+CONFIG_EOS=y
 CONFIG_ASPEED_SOC=y
 CONFIG_NETDUINO2=y
 CONFIG_MPS2=y
diff --git a/disas/arm.c b/disas/arm.c
index 7d940f23..7d19fb84 100644
--- a/disas/arm.c
+++ b/disas/arm.c
@@ -2826,9 +2826,9 @@ print_insn_arm_internal (bfd_vma pc, struct disassemble_info *info, long given)
 		      if ((given & 0x02000000) != 0)
 			{
 			  int rotate = (given & 0xf00) >> 7;
-			  int immed = (given & 0xff);
-			  immed = (((immed << (32 - rotate))
-				    | (immed >> rotate)) & 0xffffffff);
+			  int64_t immed64 = (given & 0xff);
+			  int immed = (((immed64 << (32 - rotate))
+				      | (immed64 >> rotate)) & 0xffffffff);
 			  func (stream, "#%d\t; 0x%x", immed, immed);
 			}
 		      else
@@ -3868,7 +3868,7 @@ int
 print_insn_arm (bfd_vma pc, struct disassemble_info *info)
 {
   unsigned char b[4];
-  long		given;
+  unsigned long given;
   int           status;
   int           is_thumb = false;
   int           is_data = false;
diff --git a/exec.c b/exec.c
index ffdb5185..772b9e51 100644
--- a/exec.c
+++ b/exec.c
@@ -2050,7 +2050,9 @@ void qemu_ram_set_idstr(RAMBlock *new_block, const char *name, DeviceState *dev)
     RAMBlock *block;
 
     assert(new_block);
-    assert(!new_block->idstr[0]);
+    // FIXME this fails, but I don't know why.  What's supposed to set this?
+    // Commenting it out doesn't obviously break anything...
+    //assert(!new_block->idstr[0]);
 
     if (dev) {
         char *id = qdev_get_dev_path(dev);
diff --git a/hw/Makefile.objs b/hw/Makefile.objs
index 66eef205..90c74fe3 100644
--- a/hw/Makefile.objs
+++ b/hw/Makefile.objs
@@ -10,6 +10,7 @@ devices-dirs-y += char/
 devices-dirs-y += cpu/
 devices-dirs-y += display/
 devices-dirs-y += dma/
+devices-dirs-$(CONFIG_EOS) += eos/
 devices-dirs-y += gpio/
 devices-dirs-$(CONFIG_HYPERV) += hyperv/
 devices-dirs-$(CONFIG_I2C) += i2c/
diff --git a/hw/arm/Kconfig b/hw/arm/Kconfig
index c6e77825..5896cb42 100644
--- a/hw/arm/Kconfig
+++ b/hw/arm/Kconfig
@@ -39,6 +39,11 @@ config DIGIC
     select PTIMER
     select PFLASH_CFI02
 
+config EOS
+    bool
+    select PTIMER
+    select PFLASH_CFI02
+
 config EXYNOS4
     bool
     select A9MPCORE
diff --git a/hw/arm/digic.c b/hw/arm/digic.c
index 22434a65..2eb4212c 100644
--- a/hw/arm/digic.c
+++ b/hw/arm/digic.c
@@ -41,7 +41,7 @@ static void digic_init(Object *obj)
                             &error_abort, NULL);
 
     for (i = 0; i < DIGIC4_NB_TIMERS; i++) {
-#define DIGIC_TIMER_NAME_MLEN    11
+#define DIGIC_TIMER_NAME_MLEN    20
         char name[DIGIC_TIMER_NAME_MLEN];
 
         snprintf(name, DIGIC_TIMER_NAME_MLEN, "timer[%d]", i);
diff --git a/include/exec/exec-all.h b/include/exec/exec-all.h
index d85e610e..3db650f5 100644
--- a/include/exec/exec-all.h
+++ b/include/exec/exec-all.h
@@ -590,4 +590,7 @@ hwaddr memory_region_section_get_iotlb(CPUState *cpu,
 /* vl.c */
 extern int singlestep;
 
+void cpu_set_tb_exec_cb(void (*cb)(void *opaque, CPUState *cpu, TranslationBlock *tb),
+                        void *opaque);
+
 #endif
diff --git a/include/exec/log.h b/include/exec/log.h
index e2cfd436..f987697f 100644
--- a/include/exec/log.h
+++ b/include/exec/log.h
@@ -28,7 +28,7 @@ static inline void log_cpu_state(CPUState *cpu, int flags)
  *
  * Logs the output of cpu_dump_state() if loglevel includes @mask.
  */
-static inline void log_cpu_state_mask(int mask, CPUState *cpu, int flags)
+static inline void log_cpu_state_mask(uint64_t mask, CPUState *cpu, int flags)
 {
     if (qemu_loglevel & mask) {
         log_cpu_state(cpu, flags);
diff --git a/include/exec/memory.h b/include/exec/memory.h
index e499dc21..8357791a 100644
--- a/include/exec/memory.h
+++ b/include/exec/memory.h
@@ -2244,6 +2244,19 @@ static inline MemOp devend_memop(enum device_endian end)
 }
 #endif
 
+/* memory_set_access_logging_cb: allow logging guest memory accesses
+ * using callbacks.
+ * 
+ * Currently implemented only for ARM 32-bit (LDR/STR).
+ * 
+ * @mem_log_cb: callback to be called when memory access takes place
+ * @opaque: argument passed to mem_log_cb
+ * @access_mode: bit field (PROT_READ, PROT_WRITE); fixme - better constants? define new ones?
+ */
+void memory_set_access_logging_cb(
+    void (*mem_log_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write),
+    void * opaque, int access_mode);
+
 #endif
 
 #endif
diff --git a/include/hw/elf_ops.h b/include/hw/elf_ops.h
index e07d276d..66be2b3a 100644
--- a/include/hw/elf_ops.h
+++ b/include/hw/elf_ops.h
@@ -156,8 +156,11 @@ static int glue(load_symbols, SZ)(struct elfhdr *ehdr, int fd, int must_swab,
         /* We are only interested in function symbols.
            Throw everything else away.  */
         if (syms[i].st_shndx == SHN_UNDEF ||
-                syms[i].st_shndx >= SHN_LORESERVE ||
-                ELF_ST_TYPE(syms[i].st_info) != STT_FUNC) {
+           (!(syms[i].st_shndx == SHN_ABS &&         /* allow ABS symbols (ML stubs) */
+              ELF_ST_TYPE(syms[i].st_info) == STT_NOTYPE &&
+              syms[i].st_size == 0) &&
+              (syms[i].st_shndx >= SHN_LORESERVE ||
+               ELF_ST_TYPE(syms[i].st_info) != STT_FUNC))) {
             nsyms--;
             if (i < nsyms) {
                 syms[i] = syms[nsyms];
@@ -173,9 +176,13 @@ static int glue(load_symbols, SZ)(struct elfhdr *ehdr, int fd, int must_swab,
     syms = g_realloc(syms, nsyms * sizeof(*syms));
 
     qsort(syms, nsyms, sizeof(*syms), glue(symcmp, SZ));
-    for (i = 0; i < nsyms - 1; i++) {
+    for (i = 0; i < nsyms; i++) {
         if (syms[i].st_size == 0) {
-            syms[i].st_size = syms[i + 1].st_value - syms[i].st_value;
+            if (syms[i].st_shndx == SHN_ABS) {
+                syms[i].st_size = 4;
+            } else if (i + 1 < nsyms) {
+                syms[i].st_size = syms[i + 1].st_value - syms[i].st_value;
+            }
         }
     }
 
diff --git a/include/qemu/bswap.h b/include/qemu/bswap.h
index 2a9f3fe7..6cb12875 100644
--- a/include/qemu/bswap.h
+++ b/include/qemu/bswap.h
@@ -2,6 +2,7 @@
 #define BSWAP_H
 
 #include "fpu/softfloat-types.h"
+#include "qemu/compiler.h"
 
 #ifdef CONFIG_MACHINE_BSWAP_H
 # include <sys/endian.h>
diff --git a/include/qemu/log-for-trace.h b/include/qemu/log-for-trace.h
index 2f0a5b08..89976a08 100644
--- a/include/qemu/log-for-trace.h
+++ b/include/qemu/log-for-trace.h
@@ -19,12 +19,12 @@
 #define QEMU_LOG_FOR_TRACE_H
 
 /* Private global variable, don't use */
-extern int qemu_loglevel;
+extern uint64_t qemu_loglevel;
 
 #define LOG_TRACE          (1 << 15)
 
 /* Returns true if a bit is set in the current loglevel mask */
-static inline bool qemu_loglevel_mask(int mask)
+static inline bool qemu_loglevel_mask(uint64_t mask)
 {
     return (qemu_loglevel & mask) != 0;
 }
diff --git a/include/qemu/log.h b/include/qemu/log.h
index a91105b2..16f60303 100644
--- a/include/qemu/log.h
+++ b/include/qemu/log.h
@@ -47,6 +47,47 @@ static inline bool qemu_log_separate(void)
 #define CPU_LOG_TB_FPU     (1 << 17)
 #define CPU_LOG_PLUGIN     (1 << 18)
 
+/* various EOS options */
+/* some of them are just defined for future use */
+#define EOS_LOG_IO         (1LL << 21)
+#define EOS_LOG_IO_LOG     (1LL << 22)
+#define EOS_LOG_UART       (1LL << 23)
+#define EOS_LOG_MPU        (1LL << 24)
+#define EOS_LOG_SDCF       (1LL << 25)
+#define EOS_LOG_SFLASH     (1LL << 26)
+#define EOS_LOG_PFLASH     (1LL << 27)
+#define EOS_LOG_DMA        (1LL << 28)
+#define EOS_LOG_EDMAC      (1LL << 29)
+
+#define EOS_LOG_VERBOSE    (1LL << 32)
+#define EOS_LOG_AUTOEXEC   (1LL << 33)
+
+/* guest memory tracing (logging) */
+#define EOS_LOG_RAM_R      (1LL << 40)      /* memory logging backends */
+#define EOS_LOG_RAM_W      (1LL << 41)      /* used by other analysis tools, but not printed directly */
+#define EOS_LOG_ROM_R      (1LL << 42)      /* these backends have additional overhead on generated code */
+#define EOS_LOG_ROM_W      (1LL << 43)      /* so they are only enabled when actually used */
+#define EOS_LOG_RAM        (EOS_LOG_RAM_R | EOS_LOG_RAM_W)
+#define EOS_LOG_ROM        (EOS_LOG_ROM_R | EOS_LOG_ROM_W)
+#define EOS_LOG_MEM_R      (EOS_LOG_RAM_R | EOS_LOG_ROM_R)
+#define EOS_LOG_MEM_W      (EOS_LOG_RAM_W | EOS_LOG_ROM_W)
+#define EOS_LOG_MEM        (EOS_LOG_RAM   | EOS_LOG_ROM)
+#define EOS_PR(mem_flag)  ((mem_flag) << 4) /* memory logging printed in logs (duplicate the above flags) */
+                                            /* this will take 4 bits: 40-43 => 44-47 */
+#define EOS_LOG_RAM_DBG    (1LL << 48)      /* self-test */
+#define EOS_LOG_TASKS      (1LL << 49)      /* task switches */
+#define EOS_LOG_DEBUGMSG   (1LL << 50)      /* DebugMsg calls */
+
+/* analysis tools */
+#define EOS_LOG_CALLSTACK  (1LL << 51)      /* backend: provide call stack to other tools */
+#define EOS_LOG_CALLS      (1LL << 52)      /* log all calls and returns to console */
+#define EOS_LOG_IDC        (1LL << 53)      /* export unique calls to IDA */
+#define EOS_LOG_RAM_MEMCHK (1LL << 54)      /* like valgrind memcheck */
+#define EOS_LOG_RAM_TSKMEM (1LL << 55)      /* check task memory ownership assumptions */
+#define EOS_LOG_RAM_SEMCHK (1LL << 56)      /* check semaphore usage (like helgrind) */
+#define EOS_LOG_ROMCPY     (1LL << 57)      /* find memory blocks copied from ROM to RAM */
+#define EOS_LOG_NO_TAIL_CALLS (1LL << 58)   /* don't attempt to identify tail calls */
+
 /* Lock output for a series of related logs.  Since this is not needed
  * for a single qemu_log / qemu_log_mask / qemu_log_mask_and_addr, we
  * assume that qemu_loglevel_mask has already been tested, and that
@@ -106,19 +147,19 @@ qemu_log_vprintf(const char *fmt, va_list va)
 
 /* define log items */
 typedef struct QEMULogItem {
-    int mask;
+    uint64_t mask;
     const char *name;
     const char *help;
 } QEMULogItem;
 
 extern const QEMULogItem qemu_log_items[];
 
-void qemu_set_log(int log_flags);
+void qemu_set_log(uint64_t log_flags);
 void qemu_log_needs_buffers(void);
 void qemu_set_log_filename(const char *filename, Error **errp);
 void qemu_set_dfilter_ranges(const char *ranges, Error **errp);
 bool qemu_log_in_addr_range(uint64_t addr);
-int qemu_str_to_log_mask(const char *str);
+uint64_t qemu_str_to_log_mask(const char *str);
 
 /* Print a usage message listing all the valid logging categories
  * to the specified FILE*.
diff --git a/memory.c b/memory.c
index 06484c2b..b5c8e63a 100644
--- a/memory.c
+++ b/memory.c
@@ -1417,6 +1417,10 @@ MemTxResult memory_region_dispatch_read(MemoryRegion *mr,
 
     if (!memory_region_access_valid(mr, addr, size, false, attrs)) {
         *pval = unassigned_mem_read(mr, addr, size);
+        fprintf(stderr, "[EOS] MEMTX invalid read - addr, size: 0x%lx, 0x%x\n", addr, size);
+        // the cause needs investigating, but if this is due to a read from normal ram
+        // that would succeed on real cam, extending ram_extra in model_list.c may be appropriate.
+        assert(0);
         return MEMTX_DECODE_ERROR;
     }
 
@@ -1461,6 +1465,10 @@ MemTxResult memory_region_dispatch_write(MemoryRegion *mr,
 
     if (!memory_region_access_valid(mr, addr, size, true, attrs)) {
         unassigned_mem_write(mr, addr, data, size);
+        fprintf(stderr, "[EOS] MEMTX invalid write - addr, size: 0x%lx, 0x%x\n", addr, size);
+        // the cause needs investigating, but if this is due to a write from normal ram
+        // that would succeed on real cam, extending ram_extra in model_list.c may be appropriate.
+        assert(0);
         return MEMTX_DECODE_ERROR;
     }
 
@@ -2398,6 +2406,9 @@ void memory_region_add_subregion(MemoryRegion *mr,
                                  hwaddr offset,
                                  MemoryRegion *subregion)
 {
+    fprintf(stderr, "%08X - %08X: %s\n",
+                     (int)offset, (int)offset + (int)int128_getlo(subregion->size) - 1,
+                     subregion->name);
     subregion->priority = 0;
     memory_region_add_subregion_common(mr, offset, subregion);
 }
diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 7a4ac933..bc3005d3 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -979,6 +979,7 @@ static void arm_cpu_initfn(Object *obj)
 static Property arm_cpu_reset_cbar_property =
             DEFINE_PROP_UINT64("reset-cbar", ARMCPU, reset_cbar, 0);
 
+/* fixme: how to change this property from machine code? */
 static Property arm_cpu_reset_hivecs_property =
             DEFINE_PROP_BOOL("reset-hivecs", ARMCPU, reset_hivecs, false);
 
@@ -1723,6 +1724,105 @@ static void arm926_initfn(Object *obj)
     cpu->isar.mvfr0 = FIELD_DP32(cpu->isar.mvfr0, MVFR0, FPSHVEC, 1);
     cpu->isar.mvfr0 = FIELD_DP32(cpu->isar.mvfr0, MVFR0, FPDP, 1);
 }
+ 
+static void arm946_eos_initfn(Object *obj)
+{
+    /* https://chdk.setepontos.com/index.php?topic=2139.msg19836#msg19836 */
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->dtb_compatible = "arm,arm946";
+    set_feature(&cpu->env, ARM_FEATURE_V5);
+    set_feature(&cpu->env, ARM_FEATURE_PMSA);
+    set_feature(&cpu->env, ARM_FEATURE_DUMMY_C15_REGS);
+    cpu->midr        = 0x41059461;
+    cpu->ctr         = 0x0F112112;                /* DIGIC 5: 0x0F192192 */
+    cpu->tcmtr       = 0x000C00C0;
+    cpu->reset_sctlr = 0x00000078 | (1 << 13);    /* fixme: how to change the HIVECS property? */
+    set_feature(&cpu->env, ARM_FEATURE_946EOS);
+}
+
+static void arm946_eos5_initfn(Object *obj)
+{
+    /* mostly identical to DIGIC 2..4, with minor differences */
+    arm946_eos_initfn(obj);
+
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->ctr = 0x0F192192;
+}
+
+static void cortex_r5_initfn(Object *obj);
+
+static void cortex_r4_eos_initfn(Object *obj)
+{
+    /* Cortex R4: https://chdk.setepontos.com/index.php?topic=11316.msg124273#msg124273 */
+    cortex_r5_initfn(obj);
+
+    /* https://www.magiclantern.fm/forum/index.php?topic=17714.0 */
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->midr = 0x411FC143;
+    cpu->ctr = 0x8003C003;
+    cpu->tcmtr = 0x00010001;
+    cpu->id_mmfr3 = 0x00000011;
+    cpu->isar.id_isar0 = 0x01101111;
+    cpu->isar.id_isar2 = 0x21232131;
+    cpu->clidr = 0x09000003;
+    cpu->ccsidr[0] = 0xF00FE019;
+    cpu->ccsidr[1] = 0xF00FE019;
+    cpu->dbgdidr = 0x77040013;  /* https://www.magiclantern.fm/forum/index.php?topic=17360.msg202322#msg202322 */
+    cpu->reset_sctlr = 0x08E50878 | (1 << 13);    /* fixme: how to change the HIVECS property? */
+    //        1=MPU,        2=align,      4=DCacheL1,  8=SBO        => 8
+    //       10=SBO,       20=SBO,       40=SBO,      80=SBZ        => 7
+    //      100=SBZ,      200=SBZ,      400=SBZ,     800=Z(SBO)     => 8
+    //     1000=ICacheL1,2000=HIVECS,  4000=RR,     8000=SBZ        => 2 (1 << 13)
+    //    10000=SBO,    20000=BR,     40000=SBO,   80000=DZ         => 5
+    //   100000=SBZ,   200000=FI/SBO,400000=SBO,  800000=SBO        => E
+    //  1000000=VE,   2000000=EE,   4000000=SBZ, 8000000=NMFIQ      => 8
+    // 10000000=TRE, 20000000=AFE, 40000000=TE, 80000000=IE         => 0
+    // bic                0x20000   (disable background region)
+    // orr                    0x1   (enable MPU)
+    // bic              0x1002000   (disable HIVECS, VE?!)
+    // orr                   1004   (enable L1 DCache & ICache)
+    // ->reset_sctlr = 0x08E5187D;  /* as printed by CHDK cpuinfo running from bootloader */
+    cpu->reset_auxcr = 0x00000020;  /* ACTLR */
+    unset_feature(&cpu->env, ARM_FEATURE_V7MP);
+}
+
+static void cortex_a9_initfn(Object *obj);
+
+static void cortex_a9_eos_initfn(Object *obj)
+{
+    /* Cortex A9: http://chdk.setepontos.com/index.php?topic=13014.msg131110#msg131110 */
+    cortex_a9_initfn(obj);
+
+    /* https://www.magiclantern.fm/forum/index.php?topic=19737.msg200737#msg200737 */
+    ARMCPU *cpu = ARM_CPU(obj);
+    cpu->midr = 0x414FC091;
+    cpu->ctr = 0x83338003;
+    cpu->id_pfr0 = 0x00001231;
+    cpu->id_pfr1 = 0x00000011;
+    cpu->id_dfr0 = 0x00010444;
+    cpu->id_mmfr3 = 0x00102111;
+    cpu->isar.id_isar4 = 0x00011142;
+    cpu->clidr = 0x09200003;
+    cpu->ccsidr[0] = 0x700FE019;
+    cpu->ccsidr[1] = 0x200FE019;
+    cpu->reset_sctlr = 0x08C50078;  /* best guess */
+    //        1=MMU,        2=align,      4=DCache,    8=SBO        => 8
+    //       10=SBO,       20=SBO,       40=SBO,      80=SBZ        => 7
+    //      100=SBZ,      200=SBZ,      400=SWP,     800=Z(BP)      => 0 
+    //     1000=ICache,  2000=HIVECS,  4000=RR,     8000=SBZ        => 0
+    //    10000=SBO,    20000=SBZ,    40000=SBO,   80000=SBZ        => 5
+    //   100000=SBZ,   200000=SBZ,   400000=SBO,  800000=SBO        => C
+    //  1000000=SBZ,  2000000=EE,   4000000=SBZ, 8000000=NMFIQ      => 8
+    // 10000000=TRE, 20000000=AFE, 40000000=TE, 80000000=SBZ        => 0
+    // bic              0x1003005   (disable MMU, DCache, ICache, HIVECS, ???)
+    // orr             0x40000800   (enable branch predictor and Thumb exceptions)
+    // orr                   1005   (enable MMU, DCache, ICache)
+    // ->reset_sctlr = 0x48C5187D;  /* as printed by CHDK cpuinfo running from bootloader */
+    cpu->reset_auxcr = 0x00000045;  /* ACTLR */
+    //cpu->actlr2    = 0x00000201;
+    //cpu->cpacr     = 0xC0000000;
+    //cpu->dbgdidr   = TODO;
+}
 
 static void arm946_initfn(Object *obj)
 {
@@ -2025,9 +2125,18 @@ static void arm_v7m_class_init(ObjectClass *oc, void *data)
 
 static const ARMCPRegInfo cortexr5_cp_reginfo[] = {
     /* Dummy the TCM region regs for the moment */
-    { .name = "ATCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 0,
+    /* fixme: resetvalue hardcoded for DIGIC 6 */
+    { .name = "ATCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 1,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_atcm), .resetvalue = 0x00000015 },
+    { .name = "BTCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 0,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_btcm), .resetvalue = 0x8000001D },
+    { .name = "BUILDOPTS",  .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = CP_ANY,
       .access = PL1_RW, .type = ARM_CP_CONST },
-    { .name = "BTCM", .cp = 15, .opc1 = 0, .crn = 9, .crm = 1, .opc2 = 1,
+    { .name = "BUILDOPTS1", .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = 0,
+      .access = PL1_RW, .type = ARM_CP_CONST | ARM_CP_OVERRIDE, .resetvalue = 0x00010000 },
+    { .name = "BUILDOPTS2", .cp = 15, .opc1 = 0, .crn = 15, .crm = 2, .opc2 = 1,
+      .access = PL1_RW, .type = ARM_CP_CONST | ARM_CP_OVERRIDE, .resetvalue = 0x00CFC010 },
+    { .name = "ACTLR2",     .cp = 15, .opc1 = 0, .crn = 15, .crm = 0, .opc2 = 0,
       .access = PL1_RW, .type = ARM_CP_CONST },
     { .name = "DCACHE_INVAL", .cp = 15, .opc1 = 0, .crn = 15, .crm = 5,
       .opc2 = 0, .access = PL1_W, .type = ARM_CP_NOP },
@@ -2544,6 +2653,8 @@ static const ARMCPUInfo arm_cpus[] = {
 #if !defined(CONFIG_USER_ONLY) || !defined(TARGET_AARCH64)
     { .name = "arm926",      .initfn = arm926_initfn },
     { .name = "arm946",      .initfn = arm946_initfn },
+    { .name = "arm946-eos",  .initfn = arm946_eos_initfn },
+    { .name = "arm946-eos5", .initfn = arm946_eos5_initfn },
     { .name = "arm1026",     .initfn = arm1026_initfn },
     /* What QEMU calls "arm1136-r2" is actually the 1136 r0p2, i.e. an
      * older core than plain "arm1136". In particular this does not
@@ -2559,6 +2670,7 @@ static const ARMCPUInfo arm_cpus[] = {
                              .class_init = arm_v7m_class_init },
     { .name = "cortex-m4",   .initfn = cortex_m4_initfn,
                              .class_init = arm_v7m_class_init },
+    { .name = "cortex-r4-eos",.initfn = cortex_r4_eos_initfn },
     { .name = "cortex-m33",  .initfn = cortex_m33_initfn,
                              .class_init = arm_v7m_class_init },
     { .name = "cortex-r5",   .initfn = cortex_r5_initfn },
@@ -2566,6 +2678,7 @@ static const ARMCPUInfo arm_cpus[] = {
     { .name = "cortex-a7",   .initfn = cortex_a7_initfn },
     { .name = "cortex-a8",   .initfn = cortex_a8_initfn },
     { .name = "cortex-a9",   .initfn = cortex_a9_initfn },
+    { .name = "cortex-a9-eos",.initfn = cortex_a9_eos_initfn },
     { .name = "cortex-a15",  .initfn = cortex_a15_initfn },
     { .name = "ti925t",      .initfn = ti925t_initfn },
     { .name = "sa1100",      .initfn = sa1100_initfn },
diff --git a/target/arm/cpu.h b/target/arm/cpu.h
index c3ab47d8..68e508a9 100644
--- a/target/arm/cpu.h
+++ b/target/arm/cpu.h
@@ -491,6 +491,9 @@ typedef struct CPUARMState {
         uint64_t pmccfiltr_el0; /* Performance Monitor Filter Register */
         uint64_t vpidr_el2; /* Virtualization Processor ID Register */
         uint64_t vmpidr_el2; /* Virtualization Multiprocessor ID Register */
+
+        uint32_t c15_atcm;
+        uint32_t c15_btcm;
     } cp15;
 
     struct {
@@ -868,6 +871,7 @@ struct ARMCPU {
     uint32_t revidr;
     uint32_t reset_fpsid;
     uint32_t ctr;
+    uint32_t tcmtr;
     uint32_t reset_sctlr;
     uint32_t id_pfr0;
     uint32_t id_pfr1;
@@ -1848,6 +1852,7 @@ enum arm_features {
     ARM_FEATURE_VBAR, /* has cp15 VBAR */
     ARM_FEATURE_M_SECURITY, /* M profile Security Extension */
     ARM_FEATURE_M_MAIN, /* M profile Main Extension */
+    ARM_FEATURE_946EOS,    /* EOS-specific (DIGIC 2...5) */
 };
 
 static inline int arm_feature(CPUARMState *env, int feature)
diff --git a/target/arm/helper.c b/target/arm/helper.c
index 9893fb19..d962b0f1 100644
--- a/target/arm/helper.c
+++ b/target/arm/helper.c
@@ -833,6 +833,13 @@ static const ARMCPRegInfo not_v6_cp_reginfo[] = {
     REGINFO_SENTINEL
 };
 
+static const ARMCPRegInfo eos_wfi_cp_reginfo[] = {
+    /* similar to not_v6_cp_reginfo, but .crn was changed from 7 to 15 */
+    { .name = "WFI_v5", .cp = 15, .crn = 15, .crm = 8, .opc1 = 0, .opc2 = 2,
+      .access = PL1_W, .type = ARM_CP_WFI },
+    REGINFO_SENTINEL
+};
+
 static const ARMCPRegInfo not_v7_cp_reginfo[] = {
     /* Standard v6 WFI (also used in some pre-v6 cores); not in v7 (which
      * is UNPREDICTABLE; we choose to NOP as most implementations do).
@@ -882,6 +889,138 @@ static const ARMCPRegInfo not_v7_cp_reginfo[] = {
     REGINFO_SENTINEL
 };
 
+static const ARMCPRegInfo eos_tcm_cp_reginfo[] = {
+    { .name = "ITCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 1,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_atcm), .resetvalue = 0x00000006 },
+    { .name = "DTCM",       .cp = 15, .opc1 = 0, .crn = 9,  .crm = 1, .opc2 = 0,
+      .access = PL1_RW,     .fieldoffset = offsetof(CPUARMState, cp15.c15_btcm), .resetvalue = 0x40000006 },
+    REGINFO_SENTINEL
+};
+
+/* ARM946E-S (EOS) cache lockdown emulation */
+/* note: the model is very incomplete, just enough to emulate
+ * the cache hacks from Magic Lantern */
+
+struct cache_patch
+{
+    uint32_t addr;
+    uint32_t old;
+    uint32_t new;
+};
+
+static struct cache_patch cache_patches[32];
+
+static int num_cache_patches = 0;
+
+
+static uint64_t eos_cache_lockdown_read(CPUARMState *env, const ARMCPRegInfo *ri)
+{
+    fprintf(stderr, "Lockdown read %x\n", ri->crm);
+    return 0;
+}
+
+static void eos_cache_patch(uint32_t addr, uint32_t value)
+{
+    uint32_t old;
+    cpu_physical_memory_read(addr, &old, sizeof(old));
+    
+    if (value != old)
+    {
+        fprintf(stderr, "Cache patch: [%08X] <- %X (was %X)\n", addr, value, old);
+        cache_patches[num_cache_patches++] = (struct cache_patch) { .addr = addr, .old = old, .new = value };
+        cpu_physical_memory_write(addr, &value, sizeof(value));
+    }
+}
+
+static void eos_revert_cache_patches(void)
+{
+    for ( ; num_cache_patches > 0; num_cache_patches--)
+    {
+        struct cache_patch * p = &cache_patches[num_cache_patches - 1];
+        fprintf(stderr, "Reverting cache patch: [%08X] <- %X (was patched to %X)\n", p->addr, p->old, p->new);
+        cpu_physical_memory_write(p->addr, &p->old, sizeof(p->old));
+    }
+}
+
+static void eos_cache_lockdown_write(CPUARMState *env, const ARMCPRegInfo *ri, uint64_t val)
+{
+    static uint32_t index = 0;
+    static uint32_t itag = 0;
+    static uint32_t dtag = 0;
+
+    /* FIXME: not exactly accurate, just a rough approximation */
+    /* no difference is made between data and instruction cache -
+     * first cache flush or lockdown disable event will revert all cache patches */
+    switch (ri->crn)
+    {
+        case 7:
+            /* FlushICache */
+            eos_revert_cache_patches();
+            return;
+
+        case 9:
+            /* DLockDown / ILockDown */
+            if (val == 0) {
+                eos_revert_cache_patches();
+            }
+            CPREG_FIELD32(env, ri) = val;
+            return;
+
+        case 15:
+            /* see the next switch */
+            break;
+
+        default:
+            /* unreachable */
+            assert(0);
+    }
+
+    switch (ri->crm)
+    {
+        case 0:             /* cache debug index register */
+            index = val;
+            break;
+        
+        case 1:             /* icache tag */
+            itag = val;
+            break;
+        
+        case 2:             /* dcache tag */
+            dtag = val;
+            break;
+        
+        case 3:             /* icache value */
+            eos_cache_patch((itag & 0xFFFFFFE0) | (index & 0x1C), val);
+            break;
+        
+        case 4:             /* dcache value */
+            eos_cache_patch((dtag & 0xFFFFFFE0) | (index & 0x1C), val);
+            break;
+    }
+}
+
+static const ARMCPRegInfo eos_lockdown_cp_reginfo[] = {
+    { .name = "CacheDbgIdx", .cp = 15, .crn = 15, .crm = 0, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "IcacheTag",   .cp = 15, .crn = 15, .crm = 1, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DcacheTag",   .cp = 15, .crn = 15, .crm = 2, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "IcacheVal",   .cp = 15, .crn = 15, .crm = 3, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DcacheVal",   .cp = 15, .crn = 15, .crm = 4, .opc1 = 3, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    { .name = "DLockDown",   .cp = 15, .crn = 9,  .crm = 0, .opc1 = 0, .opc2 = 0,
+      .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_data),
+      .writefn = eos_cache_lockdown_write, .resetvalue = 0, .type = ARM_CP_OVERRIDE },
+    { .name = "ILockDown",   .cp = 15, .crn = 9,  .crm = 0, .opc1 = 0, .opc2 = 1,
+      .access = PL1_RW, .fieldoffset = offsetof(CPUARMState, cp15.c9_insn),
+      .writefn = eos_cache_lockdown_write, .resetvalue = 0, .type = ARM_CP_OVERRIDE },
+    { .name = "FlushICache", .cp = 15, .crn = 7, .crm = 5, .opc1 = 0, .opc2 = 0,
+      .access = PL1_RW, .readfn = eos_cache_lockdown_read, .writefn = eos_cache_lockdown_write },
+    REGINFO_SENTINEL
+};
+
 static void cpacr_write(CPUARMState *env, const ARMCPRegInfo *ri,
                         uint64_t value)
 {
@@ -6726,7 +6865,7 @@ void register_cp_regs_for_features(ARMCPU *cpu)
             /* TCMTR and TLBTR exist in v8 but have no 64-bit versions */
             { .name = "TCMTR",
               .cp = 15, .crn = 0, .crm = 0, .opc1 = 0, .opc2 = 2,
-              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = 0 },
+              .access = PL1_R, .type = ARM_CP_CONST, .resetvalue = cpu->tcmtr },
             REGINFO_SENTINEL
         };
         /* TLBTR is specific to VMSA */
@@ -6918,6 +7057,13 @@ void register_cp_regs_for_features(ARMCPU *cpu)
         define_one_arm_cp_reg(cpu, &sctlr);
     }
 
+    /* Features specific to DIGIC 2..5 (EOS) */
+    if (arm_feature(env, ARM_FEATURE_946EOS)) {
+        define_arm_cp_regs(cpu, eos_wfi_cp_reginfo);
+        define_arm_cp_regs(cpu, eos_lockdown_cp_reginfo);
+        define_arm_cp_regs(cpu, eos_tcm_cp_reginfo);
+    }
+
     if (cpu_isar_feature(aa64_lor, cpu)) {
         /*
          * A trivial implementation of ARMv8.1-LOR leaves all of these
@@ -7809,7 +7955,7 @@ uint32_t arm_phys_excp_target_el(CPUState *cs, uint32_t excp_idx,
     return target_el;
 }
 
-void arm_log_exception(int idx)
+void arm_log_exception(int idx, CPUARMState *env)
 {
     if (qemu_loglevel_mask(CPU_LOG_INT)) {
         const char *exc = NULL;
@@ -7843,7 +7989,7 @@ void arm_log_exception(int idx)
         if (!exc) {
             exc = "unknown";
         }
-        qemu_log_mask(CPU_LOG_INT, "Taking exception %d [%s]\n", idx, exc);
+        qemu_log_mask(CPU_LOG_INT, "%08X: Taking exception %d [%s]\n", env->regs[15], idx, exc);
     }
 }
 
@@ -8090,13 +8236,19 @@ static void take_aarch32_exception(CPUARMState *env, int new_mode,
         env->thumb = (env->cp15.sctlr_el[2] & SCTLR_TE) != 0;
         env->elr_el[2] = env->regs[15];
     } else {
-        /*
-         * this is a lie, as there was no c1_sys on V4T/V5, but who cares
-         * and we should just guard the thumb mode on V4
-         */
-        if (arm_feature(env, ARM_FEATURE_V4T)) {
+        if (arm_feature(env, ARM_FEATURE_V6) ||
+            arm_feature(env, ARM_FEATURE_V7) ||
+            arm_feature(env, ARM_FEATURE_V8)) {
+            /* newer processors execute the interrupts in Thumb mode
+             * if the SCTLR TE bit is enabled */
             env->thumb =
                 (A32_BANKED_CURRENT_REG_GET(env, sctlr) & SCTLR_TE) != 0;
+        } else if (arm_feature(env, ARM_FEATURE_V4T)) {
+            /* there was no c1_sys on V4T/V5,
+             * and we should just guard the thumb mode on V4
+             * note: arm946eos uses the SCTLR TE bit for something else,
+             * so we can't assume this bit being always 0 on older platforms */
+            env->thumb = 0;
         }
         env->regs[14] = env->regs[15] + offset;
     }
@@ -8497,7 +8649,7 @@ void arm_cpu_do_interrupt(CPUState *cs)
 
     assert(!arm_feature(env, ARM_FEATURE_M));
 
-    arm_log_exception(cs->exception_index);
+    arm_log_exception(cs->exception_index, env);
     qemu_log_mask(CPU_LOG_INT, "...from EL%d to EL%d\n", arm_current_el(env),
                   new_el);
     if (qemu_loglevel_mask(CPU_LOG_INT)
diff --git a/target/arm/helper.h b/target/arm/helper.h
index e345bdb7..fba10df5 100644
--- a/target/arm/helper.h
+++ b/target/arm/helper.h
@@ -78,9 +78,14 @@ DEF_HELPER_2(v8m_stackcheck, void, env, i32)
 DEF_HELPER_4(access_check_cp_reg, void, env, ptr, i32, i32)
 DEF_HELPER_3(set_cp_reg, void, env, ptr, i32)
 DEF_HELPER_2(get_cp_reg, i32, env, ptr)
+DEF_HELPER_3(print_set_cp_reg, void, env, ptr, i32)
+DEF_HELPER_3(print_get_cp_reg, void, env, ptr, i32)
 DEF_HELPER_3(set_cp_reg64, void, env, ptr, i64)
 DEF_HELPER_2(get_cp_reg64, i64, env, ptr)
 
+DEF_HELPER_3(log_ldr, void, i32, i32, i32)
+DEF_HELPER_3(log_str, void, i32, i32, i32)
+
 DEF_HELPER_2(get_r13_banked, i32, env, i32)
 DEF_HELPER_3(set_r13_banked, void, env, i32, i32)
 
diff --git a/target/arm/internals.h b/target/arm/internals.h
index f5313dd3..35a5e53a 100644
--- a/target/arm/internals.h
+++ b/target/arm/internals.h
@@ -1051,7 +1051,7 @@ bool get_phys_addr(CPUARMState *env, target_ulong address,
                    target_ulong *page_size,
                    ARMMMUFaultInfo *fi, ARMCacheAttrs *cacheattrs);
 
-void arm_log_exception(int idx);
+void arm_log_exception(int idx, CPUARMState *env);
 
 #endif /* !CONFIG_USER_ONLY */
 
diff --git a/target/arm/m_helper.c b/target/arm/m_helper.c
index 76de317e..16597875 100644
--- a/target/arm/m_helper.c
+++ b/target/arm/m_helper.c
@@ -2042,7 +2042,7 @@ void arm_v7m_cpu_do_interrupt(CPUState *cs)
     uint32_t lr;
     bool ignore_stackfaults;
 
-    arm_log_exception(cs->exception_index);
+    arm_log_exception(cs->exception_index, env);
 
     /*
      * For exceptions we just mark as pending on the NVIC, and let that
diff --git a/target/arm/op_helper.c b/target/arm/op_helper.c
index b529d6c1..0baa71a0 100644
--- a/target/arm/op_helper.c
+++ b/target/arm/op_helper.c
@@ -668,6 +668,200 @@ void HELPER(set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
     }
 }
 
+/* adapted from CHDK cpuinfo */
+static char linebuf[128];
+
+static const char *regperm_str(unsigned val) {
+    switch(val) {
+        case 0: return "P:-- U:--";
+        case 1: return "P:RW U:--";
+        case 2: return "P:RW U:R-";
+        case 3: return "P:RW U:RW";
+        case 5: return "P:R- U:--";
+        case 6: return "P:R- U:R-";
+        default:
+            return "P:?? U:??";
+    }
+}
+
+static const char *mpu_rattr(unsigned val) {
+    const char *s="";
+    const char *s2="";
+    const char *t;
+    t = (val&4)?"Shared":"Non-shared";
+    if (val&0x20) {
+        switch (val&3) {
+            case 0: s = "Inner Non-cacheable"; break;
+            case 1: s = "Inner Write-back, write-allocate"; break;
+            case 2: s = "Inner Write-through, no write-allocate"; break;
+            case 3: s = "Inner Write-back, no write-allocate"; break;
+        }
+        switch ((val&0x18)>>3) {
+            case 0: s2 = "Outer Non-cacheable"; break;
+            case 1: s2 = "Outer Write-back, write-allocate"; break;
+            case 2: s2 = "Outer Write-through, no write-allocate"; break;
+            case 3: s2 = "Outer Write-back, no write-allocate"; break;
+        }
+        sprintf(linebuf,"%s; %s; %s",s, s2, t);
+    }
+    else {
+        switch (val&0x1B) {
+            case 0: s = "Strongly ordered, shareable"; t=""; break;
+            case 1: s = "Shareable device"; t="Shareable"; break;
+            case 2: s = "Outer and Inner write-through, no write-allocate"; break;
+            case 3: s = "Outer and Inner write-back, no write-allocate"; break;
+            case 8: s = "Outer and Inner Non-cacheable"; break;
+            case 11: s = "Outer and Inner write-back, write-allocate"; break;
+            case 16: s = "Non-shareable Device"; t=""; break;
+            default: s = "(reserved)"; t="";
+        }
+        sprintf(linebuf,"%s; %s",s, t);
+    }
+    return linebuf;
+}
+
+static void print_cpu_mpidr(CPUARMState *env)
+{
+    if (arm_feature(env, ARM_FEATURE_V7MP)) {
+        ARMCPU *cpu = env_archcpu(env);
+        uint64_t mpidr = cpu->mp_affinity;
+        fprintf(stderr, "[CPU%d] ", (int) mpidr & 0xFF);
+    }
+}
+
+void HELPER(print_set_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
+{
+    const ARMCPRegInfo *ri = rip;
+    char desc[256] = "";
+
+    if (strcmp(ri->name, "DSB") == 0)
+    {
+        return;
+    }
+    
+    /* CACHEMAINT registers come in very large groups;
+     * just display how many calls there were.
+     * fixme: if there are MRC calls, the display order may be wrong
+     */
+    static int cachemaint_count = 0;
+    static uint32_t cachemaint_pc = 0;
+    if (strcmp(ri->name, "CACHEMAINT_S") == 0 ||
+        strcmp(ri->name, "CACHEMAINT") ==0)
+    {
+        cachemaint_pc = env->regs[15];
+        cachemaint_count++;
+        return;
+    }
+    else
+    {
+        if (cachemaint_count)
+        {
+            print_cpu_mpidr(env);
+            fprintf(stderr, "%08X: MCR p%d, ...          : CACHEMAINT / CACHEMAINT_S x%d (omitted)\n", cachemaint_pc, ri->cp, cachemaint_count);
+            cachemaint_count = 0;
+        }
+    }
+
+    if (strncmp(ri->name, "946_PRBS", 8) == 0 &&
+        (value & 1))
+    {
+        uint64_t base = value & 0xFFFFF000;
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 1);
+        uint64_t end = base + size - 1;
+        snprintf(desc, sizeof(desc), "(%08"PRIX64" - %08"PRIX64", 0x%"PRIX64")", base, end, size);
+
+        /* workaround to emulate io_trace */
+        /* fixme - proper solution? */
+        ARMCPU *cpu = env_archcpu(env);
+        tlb_flush(CPU(cpu));
+    }
+
+    if (strcmp(ri->name+1, "TCM") == 0)
+    {
+        uint64_t base = value & 0xFFFFF000;
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 9);
+        uint64_t end = base + size - 1;
+        snprintf(desc, sizeof(desc), "(%08"PRIX64" - %08"PRIX64", 0x%"PRIX64")", base, end, size);
+    }
+
+    if (strcmp(ri->name, "DRSR") == 0 &&
+        (value & 1))
+    {
+        uint64_t size = 1ull << (((value >> 1) & 0x1F) + 1);
+        snprintf(desc, sizeof(desc), "(0x%"PRIX64")", size);
+
+        uint32_t rgnr = env->pmsav7.rnr[M_REG_NS];
+        uint32_t base = env->pmsav7.drbar[rgnr];
+        assert(base % size == 0);
+
+        /* subregion disable bits */
+        uint32_t subregion_disable = (value & 0xFF00) >> 8;
+        if (subregion_disable)
+        {
+            /* Region sizes of less than 256 bytes do not support subregions
+             * (Cortex R4 TRM, 7.1.1 Memory regions) */
+            assert(size >= 256);
+
+            uint32_t subregion_size = size / 8;
+            for (int i = 0; i < 8; i++)
+            {
+                fprintf(stderr,
+                    "Subregion %08X - %08X: %s\n",
+                    base + subregion_size * i,
+                    base + subregion_size * (i + 1) - 1,
+                    subregion_disable & (1 << i) ? "disabled" : "enabled"
+                );
+            }
+        }
+    }
+
+    if (strcmp(ri->name, "DRACR") == 0)
+    {
+        uint32_t rattr = value & 0x3F;
+        uint32_t accpm = (value >> 8) & 3;
+        uint32_t xn    = (value >> 12) & 1;
+        snprintf(desc, sizeof(desc),
+            "(%s; %s%s)",
+            regperm_str(accpm),
+            mpu_rattr(rattr),
+            xn ? "; Execute never" : ""
+        );
+    }
+
+    print_cpu_mpidr(env);
+    fprintf(stderr, "%08X: MCR p%d,%d,Rd,cr%d,cr%d,%d: %10s <- 0x%-8X %s\n",
+        env->regs[15], ri->cp,
+        ri->opc1, ri->crn, ri->crm, ri->opc2,
+        ri->name, value, desc
+    );
+}
+
+void HELPER(print_get_cp_reg)(CPUARMState *env, void *rip, uint32_t value)
+{
+    const ARMCPRegInfo *ri = rip;
+
+    print_cpu_mpidr(env);
+    fprintf(stderr, "%08X: MRC p%d,%d,Rd,cr%d,cr%d,%d: %10s -> 0x%X\n",
+        env->regs[15], ri->cp,
+        ri->opc1, ri->crn, ri->crm, ri->opc2,
+        ri->name, value
+    );
+}
+
+/* fixme: how to pass a pointer here, to call the registered CBR directly? */
+extern void log_ldr_cb(uint32_t addr, uint32_t value, uint32_t opc);
+extern void log_str_cb(uint32_t addr, uint32_t value, uint32_t opc);
+
+void HELPER(log_ldr)(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    log_ldr_cb(addr, value, opc);
+}
+
+void HELPER(log_str)(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    log_str_cb(addr, value, opc);
+}
+
 uint32_t HELPER(get_cp_reg)(CPUARMState *env, void *rip)
 {
     const ARMCPRegInfo *ri = rip;
diff --git a/target/arm/translate.c b/target/arm/translate.c
index ad052a2a..54af422b 100644
--- a/target/arm/translate.c
+++ b/target/arm/translate.c
@@ -37,6 +37,8 @@
 #include "trace-tcg.h"
 #include "exec/log.h"
 
+#define LOG_ALL_CP_READS
+#define LOG_ALL_CP_WRITES
 
 #define ENABLE_ARCH_4T    arm_dc_feature(s, ARM_FEATURE_V4T)
 #define ENABLE_ARCH_5     arm_dc_feature(s, ARM_FEATURE_V5)
@@ -962,11 +964,78 @@ static void gen_aa32_st_i32(DisasContext *s, TCGv_i32 val, TCGv_i32 a32,
     tcg_temp_free(addr);
 }
 
+/* fixme: should be moved to memory.c and accessed somehow from there? */
+/* fixme: use MemoryRegionOps? The read callback doesn't accept address and value */
+struct mem_log
+{
+    void (*read_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write);
+    void * read_arg;
+    void (*write_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write);
+    void * write_arg;
+} mem_log;
+
+void memory_set_access_logging_cb(
+    void (*mem_log_cb)(void * opaque, hwaddr addr, uint64_t value, unsigned size, int is_write),
+    void * opaque, int access_mode)
+{
+    if (access_mode & PROT_READ) {
+        mem_log.read_cb = mem_log_cb;
+        mem_log.read_arg = opaque;
+    }
+    if (access_mode & PROT_WRITE) {
+        mem_log.write_cb = mem_log_cb;
+        mem_log.write_arg = opaque;
+    }
+}
+
+/* called from helper_log_ldr */
+void log_ldr_cb(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    if (mem_log.read_cb) {
+        unsigned size = 1 << (opc & MO_SIZE);
+        mem_log.read_cb(mem_log.read_arg, addr, value, size, 0);
+    }
+}
+
+/* called from helper_log_str */
+void log_str_cb(uint32_t addr, uint32_t value, uint32_t opc)
+{
+    if (mem_log.write_cb) {
+        unsigned size = 1 << (opc & MO_SIZE);
+        mem_log.write_cb(mem_log.write_arg, addr, value, size, 1);
+    }
+}
+
+static inline void gen_log_ldr(TCGv_i32 addr, TCGv_i32 val, int opc)
+{
+    /* called after the actual LDR, to get the value too */
+    /* only compile the logging code if a CBR was registered */
+    if (mem_log.read_cb) {
+        TCGv_i32 opc_reg = tcg_temp_new_i32();
+        tcg_gen_movi_i32(opc_reg, opc);
+        gen_helper_log_ldr(addr, val, opc_reg);
+        tcg_temp_free_i32(opc_reg);
+    }
+}
+
+static inline void gen_log_str(TCGv_i32 addr, TCGv_i32 val, int opc)
+{
+    /* called before the actual STR */
+    /* only compile the logging code if a CBR was registered */
+    if (mem_log.write_cb) {
+        TCGv_i32 opc_reg = tcg_temp_new_i32();
+        tcg_gen_movi_i32(opc_reg, opc);
+        gen_helper_log_str(addr, val, opc_reg);
+        tcg_temp_free_i32(opc_reg);
+    }
+}
+
 #define DO_GEN_LD(SUFF, OPC)                                             \
 static inline void gen_aa32_ld##SUFF(DisasContext *s, TCGv_i32 val,      \
                                      TCGv_i32 a32, int index)            \
 {                                                                        \
     gen_aa32_ld_i32(s, val, a32, index, OPC | s->be_data);               \
+    gen_log_ldr(a32, val, OPC);                                          \
 }
 
 #define DO_GEN_ST(SUFF, OPC)                                             \
@@ -974,6 +1043,7 @@ static inline void gen_aa32_st##SUFF(DisasContext *s, TCGv_i32 val,      \
                                      TCGv_i32 a32, int index)            \
 {                                                                        \
     gen_aa32_st_i32(s, val, a32, index, OPC | s->be_data);               \
+    gen_log_str(a32, val, OPC);                                          \
 }
 
 static inline void gen_aa32_frob64(DisasContext *s, TCGv_i64 val)
@@ -996,6 +1066,10 @@ static void gen_aa32_ld_i64(DisasContext *s, TCGv_i64 val, TCGv_i32 a32,
 static inline void gen_aa32_ld64(DisasContext *s, TCGv_i64 val,
                                  TCGv_i32 a32, int index)
 {
+    if (mem_log.read_cb) {
+        /* not implemented */
+        assert(0);
+    }
     gen_aa32_ld_i64(s, val, a32, index, MO_Q | s->be_data);
 }
 
@@ -1019,6 +1093,10 @@ static void gen_aa32_st_i64(DisasContext *s, TCGv_i64 val, TCGv_i32 a32,
 static inline void gen_aa32_st64(DisasContext *s, TCGv_i64 val,
                                  TCGv_i32 a32, int index)
 {
+    if (mem_log.write_cb) {
+        /* not implemented */
+        assert(0);
+    }
     gen_aa32_st_i64(s, val, a32, index, MO_Q | s->be_data);
 }
 
@@ -6968,6 +7046,27 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
         /* Handle special cases first */
         switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {
         case ARM_CP_NOP:
+            #if defined(LOG_ALL_CP_READS) || defined(LOG_ALL_CP_WRITES)
+            if (!is64) {
+                /* log all reads to coprocessor registers (32-bit) */
+                TCGv_ptr tmpptr;
+                TCGv_i32 tmp;
+                tmpptr = tcg_const_ptr(ri);
+                if (isread) {
+                    #ifdef LOG_ALL_CP_READS
+                    tmp = load_cpu_offset(ri->fieldoffset);
+                    gen_helper_print_get_cp_reg(cpu_env, tmpptr, tmp);
+                    #endif
+                } else {
+                    #ifdef LOG_ALL_CP_WRITES
+                    tmp = load_reg(s, rt);
+                    gen_helper_print_set_cp_reg(cpu_env, tmpptr, tmp);
+                    #endif
+                }
+                tcg_temp_free_ptr(tmpptr);
+                tcg_temp_free_i32(tmp);
+            }
+            #endif
             return 0;
         case ARM_CP_WFI:
             if (isread) {
@@ -7021,6 +7120,15 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
                 } else {
                     tmp = load_cpu_offset(ri->fieldoffset);
                 }
+
+                #ifdef LOG_ALL_CP_READS
+                /* log all reads to coprocessor registers (32-bit) */
+                TCGv_ptr tmpptr;
+                tmpptr = tcg_const_ptr(ri);
+                gen_helper_print_get_cp_reg(cpu_env, tmpptr, tmp);
+                tcg_temp_free_ptr(tmpptr);
+                #endif
+
                 if (rt == 15) {
                     /* Destination register of r15 for 32 bit loads sets
                      * the condition codes from the high 4 bits of the value
@@ -7032,6 +7140,19 @@ static int disas_coproc_insn(DisasContext *s, uint32_t insn)
                 }
             }
         } else {
+            #ifdef LOG_ALL_CP_WRITES
+            if (!is64) {
+                /* log all writes to coprocessor registers (32-bit) */
+                TCGv_i32 tmp;
+                TCGv_ptr tmpptr;
+                tmp = load_reg(s, rt);
+                tmpptr = tcg_const_ptr(ri);
+                gen_helper_print_set_cp_reg(cpu_env, tmpptr, tmp);
+                tcg_temp_free_ptr(tmpptr);
+                tcg_temp_free_i32(tmp);
+            }
+            #endif
+            
             /* Write */
             if (ri->type & ARM_CP_CONST) {
                 /* If not forbidden by access permissions, treat as WI */
diff --git a/target/arm/translate.h b/target/arm/translate.h
index dd24f91f..02daa63a 100644
--- a/target/arm/translate.h
+++ b/target/arm/translate.h
@@ -290,4 +290,8 @@ void gen_cmtst_i64(TCGv_i64 d, TCGv_i64 a, TCGv_i64 b);
 #define dc_isar_feature(name, ctx) \
     ({ DisasContext *ctx_ = (ctx); isar_feature_##name(ctx_->isar); })
 
+/* fixme: duplicate declaration in op_helper.c */
+void log_ldr_cb(uint32_t addr, uint32_t value, uint32_t opc);
+void log_str_cb(uint32_t addr, uint32_t value, uint32_t opc);
+
 #endif /* TARGET_ARM_TRANSLATE_H */
diff --git a/util/log.c b/util/log.c
index 4316fe74..06edf861 100644
--- a/util/log.c
+++ b/util/log.c
@@ -27,7 +27,7 @@
 
 static char *logfilename;
 FILE *qemu_logfile;
-int qemu_loglevel;
+uint64_t qemu_loglevel;
 static int log_append = 0;
 static GArray *debug_regions;
 
@@ -52,7 +52,7 @@ int qemu_log(const char *fmt, ...)
 static bool log_uses_own_buffers;
 
 /* enable or disable low levels log */
-void qemu_set_log(int log_flags)
+void qemu_set_log(uint64_t log_flags)
 {
     qemu_loglevel = log_flags;
 #ifdef CONFIG_TRACE_LOG
@@ -268,23 +268,79 @@ const QEMULogItem qemu_log_items[] = {
       "log unimplemented functionality" },
     { LOG_GUEST_ERROR, "guest_errors",
       "log when the guest OS does something invalid (eg accessing a\n"
-      "non-existent register)" },
+      "           non-existent register)" },
     { CPU_LOG_PAGE, "page",
       "dump pages at beginning of user mode emulation" },
     { CPU_LOG_TB_NOCHAIN, "nochain",
       "do not chain compiled TBs so that \"exec\" and \"cpu\" show\n"
-      "complete traces" },
+      "           complete traces; implies -singlestep" },
 #ifdef CONFIG_PLUGIN
     { CPU_LOG_PLUGIN, "plugin", "output from TCG plugins\n"},
 #endif
+    { EOS_LOG_IO | CPU_LOG_TB_NOCHAIN, "io",
+      "EOS: log low-level I/O activity (implies nochain,singlestep)" },
+    { EOS_LOG_IO, "io_quick",
+      "EOS: log low-level I/O activity (without nochain,singlestep; PC not exact)" },
+    { EOS_LOG_IO_LOG | EOS_LOG_IO | CPU_LOG_TB_NOCHAIN, "io_log",
+      "EOS: for every I/O read, export a mmio_log entry to use in dm-spy-extra.c\n"
+      "                (dm-spy-experiments branch) to see the values from physical hardware." },
+    { EOS_LOG_MPU, "mpu",
+      "EOS: log low-level MPU activity" },
+    { EOS_LOG_SFLASH, "sflash",
+      "EOS: log low-level serial flash activity" },
+    { EOS_LOG_SDCF, "sdcf",
+      "EOS: log low-level SD/CF activity" },
+    { EOS_LOG_UART, "uart",
+      "EOS: log low-level UART activity" },
+
+    { EOS_PR(EOS_LOG_RAM) | EOS_LOG_RAM, "ram",
+      "EOS: log all RAM reads and writes" },
+    { EOS_PR(EOS_LOG_ROM) | EOS_LOG_ROM, "rom",
+      "EOS: log all ROM reads and writes" },
+    { EOS_PR(EOS_LOG_RAM_R) | EOS_LOG_RAM_R, "ramr",
+      "EOS: log all RAM reads" },
+    { EOS_PR(EOS_LOG_ROM_R) | EOS_LOG_ROM_R, "romr",
+      "EOS: log all ROM reads" },
+    { EOS_PR(EOS_LOG_RAM_W) | EOS_LOG_RAM_W, "ramw",
+      "EOS: log all RAM writes" },
+    { EOS_PR(EOS_LOG_ROM_W) | EOS_LOG_ROM_W, "romw",
+      "EOS: log all ROM writes" },
+    { EOS_LOG_RAM_DBG | EOS_LOG_RAM, "ram_dbg",
+      "EOS: self-test for the RAM logging routines" },
+
+    { EOS_LOG_CALLSTACK | CPU_LOG_TB_NOCHAIN, "callstack",
+      "EOS: reconstruct call stack (implies nochain,singlestep)" },
+    { EOS_LOG_CALLS | EOS_LOG_CALLSTACK | CPU_LOG_TB_NOCHAIN | EOS_LOG_RAM_R, "calls",
+      "EOS: log function calls (implies callstack,nochain,singlestep; monitors RAM reads)" },
+    { EOS_LOG_NO_TAIL_CALLS, "notail",
+      "EOS: don't identify tail calls (for troubleshooting)" },
+    { EOS_LOG_IDC | EOS_LOG_CALLSTACK | CPU_LOG_TB_NOCHAIN, "idc",
+      "EOS: export called functions to IDA (implies callstack,nochain,singlestep)" },
+    { EOS_LOG_TASKS, "tasks",
+      "EOS: log task switches (.current_task_addr must be defined)" },
+    { EOS_LOG_DEBUGMSG, "debugmsg",
+      "EOS: log DebugMsg calls (QEMU_EOS_DEBUGMSG must be defined)" },
+    { EOS_LOG_ROMCPY | EOS_LOG_ROM_R | EOS_LOG_RAM_W, "romcpy",
+      "EOS: find memory blocks copied from ROM to RAM" },
+
+    { EOS_LOG_RAM_MEMCHK | EOS_LOG_RAM, "memchk",
+      "EOS: check memory usage (malloc/free, uninitialized values)" },
+
+    { EOS_LOG_AUTOEXEC, "autoexec",
+      "EOS: start verbose logging when autoexec.bin is loaded (quiet logging for bootloader)" },
+
+    { EOS_LOG_VERBOSE, "v", "" },
+    { EOS_LOG_VERBOSE, "verbose",
+      "EOS: very detailed debug messages" },
+
     { 0, NULL, NULL },
 };
 
 /* takes a comma separated list of log masks. Return 0 if error. */
-int qemu_str_to_log_mask(const char *str)
+uint64_t qemu_str_to_log_mask(const char *str)
 {
     const QEMULogItem *item;
-    int mask = 0;
+    uint64_t mask = 0;
     char **parts = g_strsplit(str, ",", 0);
     char **tmp;
 
diff --git a/vl.c b/vl.c
index bf0a6345..27680198 100644
--- a/vl.c
+++ b/vl.c
@@ -3932,7 +3932,7 @@ int main(int argc, char **argv, char **envp)
     }
 
     if (log_mask) {
-        int mask;
+        uint64_t mask;
         mask = qemu_str_to_log_mask(log_mask);
         if (!mask) {
             qemu_print_log_usage(stdout);
